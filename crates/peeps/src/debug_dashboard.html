<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>vx debug — process diagnostics</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=DM+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
:root {
  --bg: #0d1117;
  --bg-raised: #151b23;
  --bg-inset: #010409;
  --surface: #1c2128;
  --surface-hover: #262c36;
  --border: #2a313a;
  --border-bright: #3d444d;
  --fg: #d1d7e0;
  --fg-muted: #7d8590;
  --fg-dim: #4a5260;

  --purple: #d2a8ff;
  --purple-bg: #d2a8ff18;
  --blue: #79c0ff;
  --blue-bg: #79c0ff18;
  --green: #56d364;
  --green-bg: #56d36418;
  --amber: #e3b341;
  --amber-bg: #e3b34118;
  --red: #f85149;
  --red-bg: #f8514918;
  --orange: #db6d28;
  --cyan: #76e3ea;

  --font-mono: 'JetBrains Mono', 'SF Mono', 'Fira Code', monospace;
  --font-sans: 'DM Sans', -apple-system, BlinkMacSystemFont, sans-serif;

  --radius: 6px;
  --radius-lg: 10px;
}

* { box-sizing: border-box; margin: 0; padding: 0; }

html, body {
  height: 100%;
  overflow: hidden;
  background: var(--bg);
  color: var(--fg);
  font-family: var(--font-sans);
  font-size: 13px;
  line-height: 1.5;
  -webkit-font-smoothing: antialiased;
}

/* ═══════════════════════════════════════════
   HEADER BAR
   ═══════════════════════════════════════════ */

.header {
  display: flex;
  align-items: center;
  gap: 16px;
  padding: 0 20px;
  height: 48px;
  background: var(--bg-raised);
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
}

.header-brand {
  display: flex;
  align-items: center;
  gap: 8px;
  font-family: var(--font-mono);
  font-weight: 700;
  font-size: 14px;
  color: var(--fg);
  letter-spacing: -0.02em;
  white-space: nowrap;
}

.header-brand .accent { color: var(--purple); }

.header-sep {
  width: 1px;
  height: 20px;
  background: var(--border);
}

.header-stats {
  display: flex;
  gap: 14px;
  font-size: 12px;
  color: var(--fg-muted);
  white-space: nowrap;
}

.header-stats .val {
  font-family: var(--font-mono);
  font-weight: 600;
  color: var(--fg);
}

.header-spacer { flex: 1; }

.search-box {
  width: 240px;
  padding: 5px 10px 5px 30px;
  border-radius: var(--radius);
  border: 1px solid var(--border);
  background: var(--bg-inset);
  color: var(--fg);
  font-family: var(--font-sans);
  font-size: 12px;
  outline: none;
  transition: border-color 0.15s;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='14' height='14' fill='%237d8590' viewBox='0 0 24 24'%3E%3Cpath d='M15.5 14h-.79l-.28-.27A6.47 6.47 0 0 0 16 9.5 6.5 6.5 0 1 0 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: 8px center;
}
.search-box:focus { border-color: var(--purple); }
.search-box::placeholder { color: var(--fg-dim); }

.btn-refresh {
  display: flex;
  align-items: center;
  gap: 5px;
  padding: 5px 12px;
  border-radius: var(--radius);
  border: 1px solid var(--border);
  background: var(--surface);
  color: var(--fg-muted);
  font-family: var(--font-sans);
  font-size: 12px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.15s;
  white-space: nowrap;
}
.btn-refresh:hover { background: var(--surface-hover); color: var(--fg); border-color: var(--border-bright); }
.btn-refresh svg { width: 13px; height: 13px; }

/* ═══════════════════════════════════════════
   TAB BAR
   ═══════════════════════════════════════════ */

.tab-bar {
  display: flex;
  gap: 0;
  padding: 0 20px;
  background: var(--bg-raised);
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
  overflow-x: auto;
}

.tab {
  position: relative;
  padding: 9px 16px;
  font-size: 12px;
  font-weight: 500;
  color: var(--fg-muted);
  cursor: pointer;
  user-select: none;
  white-space: nowrap;
  transition: color 0.15s;
  border-bottom: 2px solid transparent;
}
.tab:hover { color: var(--fg); }
.tab.active {
  color: var(--fg);
  border-bottom-color: var(--purple);
}

.tab-badge {
  display: inline-block;
  padding: 0 6px;
  margin-left: 5px;
  border-radius: 10px;
  font-size: 10px;
  font-weight: 700;
  font-family: var(--font-mono);
  background: var(--surface);
  color: var(--fg-muted);
  vertical-align: 1px;
}
.tab.active .tab-badge { background: var(--purple-bg); color: var(--purple); }

/* ═══════════════════════════════════════════
   CONTENT AREA
   ═══════════════════════════════════════════ */

.content {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
  padding: 20px;
  scrollbar-width: thin;
  scrollbar-color: var(--border) transparent;
}
.content::-webkit-scrollbar { width: 8px; }
.content::-webkit-scrollbar-track { background: transparent; }
.content::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }

.panel { display: none; }
.panel.active { display: block; animation: fadeIn 0.2s ease; }

@keyframes fadeIn { from { opacity: 0; transform: translateY(4px); } to { opacity: 1; transform: none; } }

/* ═══════════════════════════════════════════
   TOPOLOGY GRAPH
   ═══════════════════════════════════════════ */

#graph-wrap {
  width: 100%;
  height: calc(100vh - 180px);
  min-height: 400px;
  background: var(--bg-inset);
  border-radius: var(--radius-lg);
  border: 1px solid var(--border);
  position: relative;
  overflow: hidden;
}
#graph-wrap svg { display: block; width: 100%; height: 100%; }

.graph-link { fill: none; stroke-linecap: round; }
.graph-link.idle { stroke: var(--border-bright); opacity: 0.5; }
.graph-link.hot { stroke: var(--amber); }

.graph-node { cursor: grab; }
.graph-node:active { cursor: grabbing; }
.graph-node .ring { fill: none; stroke-width: 2; opacity: 0.3; }
.graph-node .core { stroke-width: 0; }
.graph-node .label {
  font-family: var(--font-mono);
  font-size: 11px;
  font-weight: 700;
  fill: var(--fg);
  text-anchor: middle;
  dominant-baseline: central;
  pointer-events: none;
}
.graph-node .sublabel {
  font-family: var(--font-mono);
  font-size: 9px;
  font-weight: 400;
  fill: var(--fg-muted);
  text-anchor: middle;
  pointer-events: none;
}

.link-label {
  font-family: var(--font-mono);
  font-size: 9px;
  fill: var(--fg-dim);
  text-anchor: middle;
  pointer-events: none;
}
.link-label.hot { fill: var(--amber); font-weight: 600; }

.graph-legend {
  position: absolute;
  bottom: 12px;
  left: 12px;
  display: flex;
  gap: 14px;
  padding: 6px 12px;
  background: var(--bg-raised);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  font-size: 11px;
  color: var(--fg-muted);
}
.graph-legend-item { display: flex; align-items: center; gap: 5px; }
.graph-legend-dot { width: 8px; height: 8px; border-radius: 50%; }

/* ═══════════════════════════════════════════
   CARDS
   ═══════════════════════════════════════════ */

.card {
  background: var(--bg-raised);
  border: 1px solid var(--border);
  border-radius: var(--radius-lg);
  overflow: hidden;
  margin-bottom: 16px;
}

.card-head {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px 16px;
  background: var(--surface);
  border-bottom: 1px solid var(--border);
  font-size: 12px;
  font-weight: 600;
}

.card-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(480px, 1fr));
  gap: 16px;
}

/* ═══════════════════════════════════════════
   TABLES
   ═══════════════════════════════════════════ */

table { width: 100%; border-collapse: collapse; }

thead th {
  position: sticky;
  top: 0;
  z-index: 1;
  text-align: left;
  padding: 8px 14px;
  background: var(--surface);
  border-bottom: 1px solid var(--border);
  font-size: 10px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.6px;
  color: var(--fg-muted);
  cursor: pointer;
  user-select: none;
  white-space: nowrap;
}
thead th:hover { color: var(--fg); }
thead th .arrow {
  display: inline-block;
  margin-left: 3px;
  font-size: 8px;
  opacity: 0.3;
  vertical-align: 1px;
}
thead th.sorted .arrow { opacity: 1; color: var(--purple); }

tbody td {
  padding: 7px 14px;
  border-bottom: 1px solid var(--border);
  font-size: 12px;
  vertical-align: top;
}
tbody tr { transition: background 0.1s; }
tbody tr:hover td { background: var(--surface-hover); }
tbody tr:last-child td { border-bottom: none; }
tbody tr.filtered-out { display: none; }

/* Row severity */
tbody tr.severity-danger td { background: var(--red-bg); }
tbody tr.severity-danger:hover td { background: #f8514925; }
tbody tr.severity-warn td { background: var(--amber-bg); }
tbody tr.severity-warn:hover td { background: #e3b34125; }

.mono { font-family: var(--font-mono); font-size: 11px; }
.num { font-family: var(--font-mono); font-variant-numeric: tabular-nums; font-size: 11px; }
.muted { color: var(--fg-muted); }
.text-red { color: var(--red); font-weight: 600; }
.text-amber { color: var(--amber); font-weight: 600; }
.text-green { color: var(--green); }
.text-muted { color: var(--fg-muted); }
.text-blue { color: var(--blue); }
.text-purple { color: var(--purple); }

/* ═══════════════════════════════════════════
   TAGS
   ═══════════════════════════════════════════ */

.tag {
  display: inline-flex;
  align-items: center;
  padding: 1px 8px;
  border-radius: 4px;
  font-size: 11px;
  font-weight: 600;
  font-family: var(--font-mono);
  white-space: nowrap;
}
.tag-vxd { background: var(--purple-bg); color: var(--purple); }
.tag-vx-store { background: var(--blue-bg); color: var(--blue); }
.tag-vx-runner { background: var(--green-bg); color: var(--green); }
.tag-vx-vfsd { background: var(--amber-bg); color: var(--amber); }

/* ═══════════════════════════════════════════
   DIRECTION ARROWS
   ═══════════════════════════════════════════ */

.dir { font-weight: 700; font-size: 14px; }
.dir-out { color: var(--green); }
.dir-in { color: var(--amber); }

/* ═══════════════════════════════════════════
   EXPANDABLE DETAILS / BACKTRACES
   ═══════════════════════════════════════════ */

.expandable { cursor: pointer; }
.expandable-content {
  display: none;
  padding: 8px 12px;
  margin-top: 4px;
  background: var(--bg-inset);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  font-family: var(--font-mono);
  font-size: 10px;
  line-height: 1.6;
  color: var(--fg-muted);
  white-space: pre-wrap;
  word-break: break-all;
  max-height: 240px;
  overflow-y: auto;
}
.expandable-content.open { display: block; animation: fadeIn 0.15s ease; }

.expand-trigger {
  display: inline-flex;
  align-items: center;
  gap: 3px;
  padding: 1px 6px;
  border-radius: 3px;
  background: var(--surface);
  border: 1px solid var(--border);
  color: var(--fg-muted);
  font-size: 10px;
  font-family: var(--font-mono);
  cursor: pointer;
  transition: all 0.1s;
}
.expand-trigger:hover { background: var(--surface-hover); color: var(--fg); }

/* ═══════════════════════════════════════════
   EMPTY STATE
   ═══════════════════════════════════════════ */

.empty-state {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 64px 24px;
  color: var(--fg-dim);
}
.empty-state .icon {
  font-size: 28px;
  margin-bottom: 12px;
  font-family: var(--font-mono);
  opacity: 0.4;
}
.empty-state p { font-size: 13px; }
.empty-state .sub { font-size: 11px; margin-top: 4px; }

/* ═══════════════════════════════════════════
   PROCESS CARDS
   ═══════════════════════════════════════════ */

.proc-card {
  background: var(--bg-raised);
  border: 1px solid var(--border);
  border-radius: var(--radius-lg);
  overflow: hidden;
}

.proc-card-head {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 12px 16px;
  border-bottom: 1px solid var(--border);
}
.proc-card-head .dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  flex-shrink: 0;
}
.proc-card-head .name {
  font-family: var(--font-mono);
  font-weight: 700;
  font-size: 14px;
}
.proc-card-head .pid {
  font-family: var(--font-mono);
  font-size: 11px;
  color: var(--fg-muted);
  margin-left: auto;
}

.proc-card-body { padding: 12px 16px; }

.proc-kv {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 6px 16px;
}
.proc-kv-item {
  display: flex;
  justify-content: space-between;
  font-size: 12px;
}
.proc-kv-item .k { color: var(--fg-muted); }
.proc-kv-item .v { font-family: var(--font-mono); font-weight: 600; }

.proc-section {
  margin-top: 10px;
  padding-top: 10px;
  border-top: 1px solid var(--border);
}

details { font-size: 12px; }
details summary {
  cursor: pointer;
  color: var(--fg-muted);
  font-size: 11px;
  padding: 4px 0;
  list-style: none;
}
details summary::-webkit-details-marker { display: none; }
details summary::before {
  content: '▸ ';
  font-size: 10px;
  color: var(--fg-dim);
}
details[open] summary::before { content: '▾ '; }

/* ═══════════════════════════════════════════
   CONNECTION PAIRS
   ═══════════════════════════════════════════ */

.conn-pair {
  display: grid;
  grid-template-columns: 1fr auto 1fr;
  gap: 0;
}

.conn-pair-divider {
  width: 1px;
  background: var(--border);
}

.conn-side {
  padding: 12px 16px;
}

.conn-side-empty {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 24px;
}

.ghost-label {
  color: var(--red);
  font-size: 12px;
  font-style: italic;
}

.conn-side-head {
  display: flex;
  align-items: center;
  margin-bottom: 10px;
  padding-bottom: 8px;
  border-bottom: 1px solid var(--border);
}

.conn-side-stats {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 4px 12px;
}

.conn-stat {
  display: flex;
  justify-content: space-between;
  align-items: baseline;
  font-size: 12px;
}

.conn-stat-k {
  color: var(--fg-muted);
  font-size: 11px;
}

.conn-stat-v {
  font-family: var(--font-mono);
  font-weight: 600;
  font-size: 11px;
}

/* ═══════════════════════════════════════════
   LAYOUT
   ═══════════════════════════════════════════ */

/* ═══════════════════════════════════════════
   SYNC STATE BADGES
   ═══════════════════════════════════════════ */

.state-badge {
  display: inline-flex;
  align-items: center;
  padding: 1px 8px;
  border-radius: 4px;
  font-size: 11px;
  font-weight: 600;
  font-family: var(--font-mono);
  white-space: nowrap;
}
.state-pending      { background: var(--amber-bg); color: var(--amber); }
.state-sent         { background: var(--green-bg); color: var(--green); }
.state-initialized  { background: var(--green-bg); color: var(--green); }
.state-initializing { background: var(--blue-bg);  color: var(--blue); }
.state-empty        { background: var(--surface);  color: var(--fg-dim); }
.state-dropped      { background: var(--red-bg);   color: var(--red); }

.backpressure-warn {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 1px 8px;
  border-radius: 4px;
  font-size: 11px;
  font-weight: 700;
  font-family: var(--font-mono);
  background: var(--red-bg);
  color: var(--red);
}

.app {
  display: flex;
  flex-direction: column;
  height: 100vh;
}
</style>
</head>
<body>
<div class="app">

  <!-- HEADER -->
  <div class="header">
    <div class="header-brand"><span class="accent">vx</span> debug</div>
    <div class="header-sep"></div>
    <div class="header-stats" id="stats"></div>
    <div class="header-spacer"></div>
    <input class="search-box" id="search" type="text" placeholder="Filter…" autocomplete="off" spellcheck="false">
    <button class="btn-refresh" onclick="location.reload()">
      <svg viewBox="0 0 24 24" fill="currentColor"><path d="M17.65 6.35A7.96 7.96 0 0012 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08A5.99 5.99 0 0112 18c-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/></svg>
      Refresh
    </button>
  </div>

  <!-- TABS -->
  <div class="tab-bar" id="tabs">
    <div class="tab active" data-tab="topology">Topology</div>
    <div class="tab" data-tab="requests">Requests <span class="tab-badge" id="badge-req">0</span></div>
    <div class="tab" data-tab="connections">Connections <span class="tab-badge" id="badge-conn">0</span></div>
    <div class="tab" data-tab="processes">Processes <span class="tab-badge" id="badge-proc">0</span></div>
    <div class="tab" data-tab="shm">SHM</div>
    <div class="tab" data-tab="locks">Locks</div>
    <div class="tab" data-tab="threads">Threads <span class="tab-badge" id="badge-threads">0</span></div>
    <div class="tab" data-tab="tasks">Tasks <span class="tab-badge" id="badge-tasks">0</span></div>
    <div class="tab" data-tab="sync" id="tab-sync" style="display:none">Sync <span class="tab-badge" id="badge-sync">0</span></div>
  </div>

  <!-- CONTENT -->
  <div class="content" id="content">
    <div class="panel active" id="panel-topology"></div>
    <div class="panel" id="panel-requests"></div>
    <div class="panel" id="panel-connections"></div>
    <div class="panel" id="panel-processes"></div>
    <div class="panel" id="panel-shm"></div>
    <div class="panel" id="panel-locks"></div>
    <div class="panel" id="panel-threads"></div>
    <div class="panel" id="panel-tasks"></div>
    <div class="panel" id="panel-sync"></div>
  </div>
</div>

<script>
// ═══════════════════════════════════════════════════════════════
// DATA
// ═══════════════════════════════════════════════════════════════

const DUMPS = __DUMPS_JSON__;

const COLORS = {
  'vxd':       { hex: '#d2a8ff', css: 'var(--purple)', tag: 'tag-vxd' },
  'vx-store':  { hex: '#79c0ff', css: 'var(--blue)',   tag: 'tag-vx-store' },
  'vx-runner': { hex: '#56d364', css: 'var(--green)',   tag: 'tag-vx-runner' },
  'vx-vfsd':   { hex: '#e3b341', css: 'var(--amber)',  tag: 'tag-vx-vfsd' },
};
function procColor(name) { return COLORS[name] || { hex: '#7d8590', css: 'var(--fg-muted)', tag: '' }; }
function procTag(name) { return `<span class="tag ${procColor(name).tag}">${esc(name)}</span>`; }

// Derived data
const allRequests = [];
const allConnections = [];
let totalInFlight = 0;
let totalCompleted = 0;

for (const d of DUMPS) {
  if (!d.roam?.connections) continue;
  for (const c of d.roam.connections) {
    allConnections.push({ process: d.process_name, pid: d.pid, ...c });
    totalCompleted += c.total_completed;
    for (const r of c.in_flight) {
      totalInFlight++;
      allRequests.push({
        process: d.process_name, pid: d.pid,
        connection: c.name, peer: c.peer_name || '?', ...r,
      });
    }
  }
}
allRequests.sort((a, b) => b.elapsed_secs - a.elapsed_secs);

// ═══════════════════════════════════════════════════════════════
// HEADER STATS
// ═══════════════════════════════════════════════════════════════

document.getElementById('stats').innerHTML = [
  `<span><span class="val">${DUMPS.length}</span> processes</span>`,
  `<span><span class="val">${allConnections.length}</span> connections</span>`,
  `<span><span class="val">${totalInFlight}</span> in-flight</span>`,
  `<span><span class="val">${totalCompleted}</span> completed</span>`,
].join('');
const totalThreads = DUMPS.reduce((s, d) => s + (d.thread_stacks ? d.thread_stacks.length : 0), 0);
document.getElementById('badge-req').textContent = allRequests.length;
document.getElementById('badge-conn').textContent = allConnections.length;
document.getElementById('badge-proc').textContent = DUMPS.length;
document.getElementById('badge-threads').textContent = totalThreads;

// ═══════════════════════════════════════════════════════════════
// TAB SWITCHING
// ═══════════════════════════════════════════════════════════════

document.querySelectorAll('.tab').forEach(t => {
  t.addEventListener('click', () => {
    document.querySelectorAll('.tab').forEach(x => x.classList.remove('active'));
    document.querySelectorAll('.panel').forEach(x => x.classList.remove('active'));
    t.classList.add('active');
    document.getElementById('panel-' + t.dataset.tab).classList.add('active');
  });
});

// ═══════════════════════════════════════════════════════════════
// SEARCH / FILTER
// ═══════════════════════════════════════════════════════════════

document.getElementById('search').addEventListener('input', function() {
  const q = this.value.toLowerCase();
  document.querySelectorAll('tbody tr').forEach(row => {
    row.classList.toggle('filtered-out', q !== '' && !row.textContent.toLowerCase().includes(q));
  });
});

// ═══════════════════════════════════════════════════════════════
// SORTABLE TABLES
// ═══════════════════════════════════════════════════════════════

function makeSortable(table) {
  const ths = table.querySelectorAll('thead th[data-sort]');
  ths.forEach((th, idx) => {
    th.innerHTML += ' <span class="arrow">▲</span>';
    th.addEventListener('click', () => {
      const tbody = table.querySelector('tbody');
      const rows = Array.from(tbody.querySelectorAll('tr'));
      const isNum = th.dataset.type === 'n';
      const wasAsc = th.classList.contains('sorted') && th.dataset.dir === 'asc';
      const dir = wasAsc ? 'desc' : 'asc';

      ths.forEach(h => { h.classList.remove('sorted'); h.dataset.dir = ''; });
      th.classList.add('sorted');
      th.dataset.dir = dir;
      th.querySelector('.arrow').textContent = dir === 'asc' ? '▲' : '▼';

      rows.sort((a, b) => {
        let va = a.children[idx]?.dataset.v ?? a.children[idx]?.textContent ?? '';
        let vb = b.children[idx]?.dataset.v ?? b.children[idx]?.textContent ?? '';
        if (isNum) { va = parseFloat(va) || 0; vb = parseFloat(vb) || 0; }
        else { va = String(va).toLowerCase(); vb = String(vb).toLowerCase(); }
        if (va < vb) return dir === 'asc' ? -1 : 1;
        if (va > vb) return dir === 'asc' ? 1 : -1;
        return 0;
      });
      rows.forEach(r => tbody.appendChild(r));
    });
  });
}

// ═══════════════════════════════════════════════════════════════
// UTILITIES
// ═══════════════════════════════════════════════════════════════

function esc(s) {
  if (typeof s !== 'string') return String(s ?? '');
  return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
}

function fmtBytes(b) {
  if (b == null) return '—';
  if (b < 1024) return b + ' B';
  if (b < 1048576) return (b / 1024).toFixed(1) + ' KB';
  if (b < 1073741824) return (b / 1048576).toFixed(1) + ' MB';
  return (b / 1073741824).toFixed(2) + ' GB';
}

function fmtDuration(s) {
  if (s >= 60) return (s / 60).toFixed(1) + 'm';
  if (s >= 1) return s.toFixed(2) + 's';
  return (s * 1000).toFixed(0) + 'ms';
}

function fmtAge(s) {
  if (s >= 3600) return (s / 3600).toFixed(1) + 'h';
  if (s >= 60) return (s / 60).toFixed(1) + 'm';
  return s.toFixed(1) + 's';
}

let _expandId = 0;
function expandBtn(content) {
  if (!content) return '<span class="muted">—</span>';
  const id = 'exp-' + (++_expandId);
  return `<span class="expand-trigger" onclick="document.getElementById('${id}').classList.toggle('open')">trace</span>
    <div class="expandable-content" id="${id}">${esc(content)}</div>`;
}

function dirArrow(d) {
  if (d === 'Outgoing') return '<span class="dir dir-out" title="outgoing">→</span>';
  return '<span class="dir dir-in" title="incoming">←</span>';
}

function methodName(r) { return r.method_name || ('method_' + r.method_id); }

// Noise prefixes to skip when looking for the first useful frame in a backtrace.
const FRAME_NOISE = [
  'std::backtrace', 'std::sys', 'backtrace_rs', 'backtrace::',
  'vx_dump::thread_stacks::sigprof_handler',
  '__os_lock', '_pthread_', 'pthread_',
  'tokio::runtime::park', 'tokio::runtime::context',
  'tokio::runtime::scheduler', 'tokio::runtime::runtime',
  'tokio::runtime::blocking',
  'core::ops::function', 'std::panicking', 'std::panic',
  'std::rt::lang_start', '<unknown>',
  'tokio::park', 'mio::poll',
];

function firstUsefulFrame(bt) {
  if (!bt) return null;
  const lines = bt.split('\n');
  for (const line of lines) {
    const trimmed = line.trim();
    // Frame lines look like "N: some::function::path"
    const m = trimmed.match(/^\d+:\s+(.+)/);
    if (!m) continue;
    const fn_name = m[1].split('\n')[0].trim();
    if (FRAME_NOISE.some(prefix => fn_name.startsWith(prefix))) continue;
    // Strip the frame number prefix for display
    return fn_name;
  }
  return null;
}

function fmtTimestamp(ts) {
  if (!ts) return '<span class="muted">—</span>';
  const d = new Date(ts);
  if (isNaN(d.getTime())) return esc(ts);
  const ago = (Date.now() - d.getTime()) / 1000;
  const rel = ago < 5 ? 'just now' : fmtAge(ago) + ' ago';
  const time = d.toLocaleTimeString();
  return `<span title="${esc(ts)}">${rel} <span class="muted">(${time})</span></span>`;
}

function fmtArgs(args) {
  if (!args || Object.keys(args).length === 0) return '<span class="muted">—</span>';
  const entries = Object.entries(args);
  const full = entries.map(([k, v]) => `${esc(k)} = ${esc(v)}`).join('\n');
  const preview = entries.map(([k, v]) => {
    const short = v.length > 60 ? v.slice(0, 60) + '…' : v;
    return `<span class="muted">${esc(k)}=</span>${esc(short)}`;
  }).join(' ');
  const id = 'args-' + (++_expandId);
  return `<span class="mono" style="font-size:10px">${preview}</span>
    <span class="expand-trigger" onclick="document.getElementById('${id}').classList.toggle('open')" style="margin-left:4px">full</span>
    <div class="expandable-content" id="${id}">${full}</div>`;
}

// ═══════════════════════════════════════════════════════════════
// TOPOLOGY GRAPH
// ═══════════════════════════════════════════════════════════════

(function buildTopology() {
  const panel = document.getElementById('panel-topology');
  panel.innerHTML = `<div id="graph-wrap">
    <div class="graph-legend">
      <div class="graph-legend-item"><div class="graph-legend-dot" style="background:var(--purple)"></div> vxd</div>
      <div class="graph-legend-item"><div class="graph-legend-dot" style="background:var(--blue)"></div> vx-store</div>
      <div class="graph-legend-item"><div class="graph-legend-dot" style="background:var(--green)"></div> vx-runner</div>
      <div class="graph-legend-item"><div class="graph-legend-dot" style="background:var(--amber)"></div> vx-vfsd</div>
    </div>
  </div>`;

  const wrap = document.getElementById('graph-wrap');
  const W = wrap.clientWidth;
  const H = wrap.clientHeight;
  const svg = d3.select(wrap).append('svg').attr('viewBox', `0 0 ${W} ${H}`);

  // Build nodes
  const nodes = DUMPS.map(d => ({
    id: d.process_name,
    pid: d.pid,
    color: procColor(d.process_name).hex,
    inFlight: (d.roam?.connections || []).reduce((s, c) => s + c.in_flight.length, 0),
    connCount: (d.roam?.connections || []).length,
  }));

  // Build links (deduplicate by source-target pair)
  const links = [];
  const seen = new Set();
  for (const d of DUMPS) {
    if (!d.roam?.connections) continue;
    for (const c of d.roam.connections) {
      if (!c.peer_name) continue;
      // Only link to known processes
      if (!DUMPS.some(x => x.process_name === c.peer_name)) continue;
      const key = [d.process_name, c.peer_name].sort().join('|');
      if (seen.has(key)) {
        const ex = links.find(l =>
          [typeof l.source === 'string' ? l.source : l.source.id,
           typeof l.target === 'string' ? l.target : l.target.id].sort().join('|') === key
        );
        if (ex) ex.inFlight += c.in_flight.length;
        continue;
      }
      seen.add(key);
      links.push({ source: d.process_name, target: c.peer_name, inFlight: c.in_flight.length });
    }
  }

  // Defs for arrowheads
  svg.append('defs').append('marker')
    .attr('id', 'arrow').attr('viewBox', '0 -3 6 6')
    .attr('refX', 30).attr('refY', 0)
    .attr('markerWidth', 6).attr('markerHeight', 6)
    .attr('orient', 'auto')
    .append('path').attr('d', 'M0,-3L6,0L0,3').attr('fill', 'var(--border-bright)');

  const sim = d3.forceSimulation(nodes)
    .force('link', d3.forceLink(links).id(d => d.id).distance(180).strength(0.7))
    .force('charge', d3.forceManyBody().strength(-600))
    .force('center', d3.forceCenter(W / 2, H / 2))
    .force('collide', d3.forceCollide(50));

  // Links
  const linkG = svg.append('g');
  const link = linkG.selectAll('line').data(links).join('line')
    .attr('class', d => 'graph-link ' + (d.inFlight > 0 ? 'hot' : 'idle'))
    .attr('stroke-width', d => Math.max(2, Math.min(10, 2 + d.inFlight * 2)));

  // Link labels
  const linkLabel = svg.append('g').selectAll('text').data(links).join('text')
    .attr('class', d => 'link-label ' + (d.inFlight > 0 ? 'hot' : ''))
    .text(d => d.inFlight > 0 ? d.inFlight + ' in-flight' : '');

  // Nodes
  const nodeG = svg.append('g').selectAll('g').data(nodes).join('g')
    .attr('class', 'graph-node')
    .call(d3.drag()
      .on('start', (e, d) => { if (!e.active) sim.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; })
      .on('drag', (e, d) => { d.fx = e.x; d.fy = e.y; })
      .on('end', (e, d) => { if (!e.active) sim.alphaTarget(0); d.fx = null; d.fy = null; })
    );

  // Outer ring (scales with in-flight)
  nodeG.append('circle').attr('class', 'ring')
    .attr('r', d => 28 + d.inFlight * 4)
    .attr('stroke', d => d.color);

  // Core circle
  nodeG.append('circle').attr('class', 'core')
    .attr('r', 22)
    .attr('fill', d => d.color + '30');

  // Process name
  nodeG.append('text').attr('class', 'label').attr('dy', -3)
    .text(d => d.id);

  // PID
  nodeG.append('text').attr('class', 'sublabel').attr('dy', 12)
    .text(d => 'pid ' + d.pid);

  sim.on('tick', () => {
    link
      .attr('x1', d => d.source.x).attr('y1', d => d.source.y)
      .attr('x2', d => d.target.x).attr('y2', d => d.target.y);
    linkLabel
      .attr('x', d => (d.source.x + d.target.x) / 2)
      .attr('y', d => (d.source.y + d.target.y) / 2 - 8);
    nodeG.attr('transform', d => `translate(${d.x},${d.y})`);
  });
})();

// ═══════════════════════════════════════════════════════════════
// REQUESTS TAB
// ═══════════════════════════════════════════════════════════════

(function buildRequests() {
  const panel = document.getElementById('panel-requests');
  if (allRequests.length === 0) {
    panel.innerHTML = '<div class="empty-state"><div class="icon">✓</div><p>No in-flight requests</p><p class="sub">All RPCs have completed — nothing stuck</p></div>';
    return;
  }

  // ── Correlate client↔server requests ──────────────────────
  // For each outgoing request on process A→B, find the matching
  // incoming request on process B (same method, from A).
  // "Ghost" requests: outgoing with no matching incoming = dispatch stall.

  const outgoing = allRequests.filter(r => r.direction === 'Outgoing');
  const incoming = allRequests.filter(r => r.direction === 'Incoming');

  // Index incoming by (process, peer, method) for fast lookup.
  // Multiple incoming requests can match the same method on the same
  // connection, so we keep a list and consume them as matched.
  const incomingPool = new Map(); // key -> [req, ...]
  for (const r of incoming) {
    const key = `${r.process}|${r.peer}|${methodName(r)}`;
    if (!incomingPool.has(key)) incomingPool.set(key, []);
    incomingPool.get(key).push(r);
  }

  const pairs = []; // { out: req, in: req|null }
  const matchedIncoming = new Set();

  for (const r of outgoing) {
    // The peer's incoming view: process=r.peer, peer=r.process, same method
    const key = `${r.peer}|${r.process}|${methodName(r)}`;
    const candidates = incomingPool.get(key);
    let match = null;
    if (candidates && candidates.length > 0) {
      // Pick the candidate with closest elapsed time
      candidates.sort((a, b) => Math.abs(a.elapsed_secs - r.elapsed_secs) - Math.abs(b.elapsed_secs - r.elapsed_secs));
      match = candidates.shift(); // consume it
      matchedIncoming.add(match);
      if (candidates.length === 0) incomingPool.delete(key);
    }
    pairs.push({ out: r, in: match });
  }

  // Any unmatched incoming requests (server sees incoming that client doesn't claim)
  for (const r of incoming) {
    if (!matchedIncoming.has(r)) {
      pairs.push({ out: null, in: r });
    }
  }

  // Sort: unmatched (ghosts) first, then by max elapsed time
  pairs.sort((a, b) => {
    const aGhost = !a.out || !a.in ? 1 : 0;
    const bGhost = !b.out || !b.in ? 1 : 0;
    if (aGhost !== bGhost) return bGhost - aGhost; // ghosts first
    const aElapsed = Math.max(a.out?.elapsed_secs || 0, a.in?.elapsed_secs || 0);
    const bElapsed = Math.max(b.out?.elapsed_secs || 0, b.in?.elapsed_secs || 0);
    return bElapsed - aElapsed;
  });

  // ── Render request card for one side ──────────────────────
  function renderReqSide(r, label) {
    if (!r) return `<div class="conn-side conn-side-empty"><span class="ghost-label">not seen by ${label}</span></div>`;
    const sev = r.elapsed_secs > 5 ? 'text-red' : r.elapsed_secs > 2 ? 'text-amber' : '';
    let h = '<div class="conn-side">';
    h += `<div class="conn-side-head">${procTag(r.process)} <span class="mono muted" style="margin-left:4px">${esc(r.connection)}</span></div>`;
    h += '<div class="conn-side-stats">';
    h += `<div class="conn-stat"><span class="conn-stat-k">Request ID</span><span class="conn-stat-v mono">${r.request_id}</span></div>`;
    h += `<div class="conn-stat"><span class="conn-stat-k">Elapsed</span><span class="conn-stat-v ${sev}">${fmtDuration(r.elapsed_secs)}</span></div>`;
    if (r.args && Object.keys(r.args).length > 0) {
      const preview = Object.entries(r.args).map(([k, v]) => {
        const short = v.length > 40 ? v.slice(0, 40) + '…' : v;
        return `<span class="muted">${esc(k)}=</span>${esc(short)}`;
      }).join(' ');
      h += `<div class="conn-stat" style="grid-column:1/-1"><span class="conn-stat-k">Args</span><span class="conn-stat-v mono" style="font-size:10px">${preview}</span></div>`;
    }
    if (r.backtrace) {
      const id = 'rbt-' + (++_expandId);
      h += `<div style="grid-column:1/-1;margin-top:4px">`;
      h += `<span class="expand-trigger" onclick="document.getElementById('${id}').classList.toggle('open')">backtrace</span>`;
      h += `<div class="expandable-content" id="${id}">${esc(r.backtrace)}</div>`;
      h += '</div>';
    }
    h += '</div></div>';
    return h;
  }

  // ── Render paired cards ───────────────────────────────────
  let html = '';

  // Summary counts
  const ghostCount = pairs.filter(p => !p.out || !p.in).length;
  const matchedCount = pairs.filter(p => p.out && p.in).length;

  if (ghostCount > 0) {
    html += `<div class="card" style="border-color:var(--red);">`;
    html += `<div class="card-head"><span style="color:var(--red)">`;
    html += `${ghostCount} unmatched request${ghostCount !== 1 ? 's' : ''}</span>`;
    html += ` <span class="muted" style="font-weight:400;font-size:12px;margin-left:8px">`;
    html += `visible on one side but not the other — likely dispatch stall</span></div></div>`;
  }

  for (const pair of pairs) {
    const r = pair.out || pair.in;
    const method = methodName(r);
    const isGhost = !pair.out || !pair.in;
    const maxElapsed = Math.max(pair.out?.elapsed_secs || 0, pair.in?.elapsed_secs || 0);
    const sev = maxElapsed > 5 ? 'var(--red)' : maxElapsed > 2 ? 'var(--amber)' : '';

    // Card header: method + processes involved
    const leftProc = pair.out ? pair.out.process : '?';
    const rightProc = pair.in ? pair.in.process : '?';
    const methodTag = `<span class="mono" style="color:var(--fg)">${esc(method)}</span>`;
    const ghostBadge = isGhost
      ? ` <span class="tag" style="background:var(--red-bg);color:var(--red);margin-left:8px">one-sided</span>`
      : '';
    const elapsed = `<span class="mono" style="margin-left:auto;${sev ? 'color:' + sev + ';' : ''}">${fmtDuration(maxElapsed)}</span>`;

    html += `<div class="card" style="${isGhost ? 'border-color:var(--red);' : sev ? 'border-color:' + sev + ';' : ''}">`;
    html += `<div class="card-head" style="display:flex;align-items:center;gap:8px">`;
    html += `${procTag(leftProc)} <span class="muted">→</span> ${methodTag} <span class="muted">→</span> ${procTag(rightProc)}${ghostBadge}${elapsed}`;
    html += '</div>';
    html += '<div class="conn-pair">';
    html += renderReqSide(pair.out, 'caller');
    html += '<div class="conn-pair-divider"></div>';
    html += renderReqSide(pair.in, 'callee');
    html += '</div>';
    html += '</div>';
  }

  // ── Also keep a flat table for sortable view ──────────────
  html += '<div class="card"><div class="card-head">All In-Flight (flat view)</div><table><thead><tr>';
  html += '<th data-sort="p">Process</th>';
  html += '<th data-sort="c">Connection</th>';
  html += '<th data-sort="d">Dir</th>';
  html += '<th data-sort="m">Method</th>';
  html += '<th>Args</th>';
  html += '<th data-sort="i" data-type="n">ID</th>';
  html += '<th data-sort="e" data-type="n">Elapsed</th>';
  html += '<th>Trace</th>';
  html += '</tr></thead><tbody>';

  for (const r of allRequests) {
    const sev = r.elapsed_secs > 5 ? 'severity-danger' : r.elapsed_secs > 2 ? 'severity-warn' : '';
    html += `<tr class="${sev}">`;
    html += `<td>${procTag(r.process)} <span class="mono muted">${r.pid}</span></td>`;
    html += `<td>${esc(r.connection)} <span class="muted">↔</span> ${esc(r.peer)}</td>`;
    html += `<td>${dirArrow(r.direction)}</td>`;
    html += `<td class="mono">${esc(methodName(r))}</td>`;
    html += `<td>${fmtArgs(r.args)}</td>`;
    html += `<td class="num" data-v="${r.request_id}">${r.request_id}</td>`;
    html += `<td class="num ${r.elapsed_secs > 5 ? 'text-red' : r.elapsed_secs > 2 ? 'text-amber' : ''}" data-v="${r.elapsed_secs}">${fmtDuration(r.elapsed_secs)}</td>`;
    html += `<td>${expandBtn(r.backtrace)}</td>`;
    html += '</tr>';
  }
  html += '</tbody></table></div>';

  panel.innerHTML = html;
  panel.querySelectorAll('table').forEach(makeSortable);
})();

// ═══════════════════════════════════════════════════════════════
// CONNECTIONS TAB
// ═══════════════════════════════════════════════════════════════

(function buildConnections() {
  const panel = document.getElementById('panel-connections');

  // Group connections into pairs: A↔B
  // A "pair" is two connections where process=X,peer=Y and process=Y,peer=X
  const pairs = [];
  const used = new Set();

  for (let i = 0; i < allConnections.length; i++) {
    if (used.has(i)) continue;
    const a = allConnections[i];
    if (!a.peer_name) {
      // Unpaired connection
      pairs.push({ left: a, right: null });
      used.add(i);
      continue;
    }
    // Find the matching peer
    let matched = false;
    for (let j = i + 1; j < allConnections.length; j++) {
      if (used.has(j)) continue;
      const b = allConnections[j];
      if (a.process === b.peer_name && b.process === a.peer_name) {
        // Found the pair — put client on left, server on right
        if (a.name === 'client') {
          pairs.push({ left: a, right: b });
        } else {
          pairs.push({ left: b, right: a });
        }
        used.add(i);
        used.add(j);
        matched = true;
        break;
      }
    }
    if (!matched) {
      pairs.push({ left: a, right: null });
      used.add(i);
    }
  }

  // Sort pairs: those with in-flight discrepancies first, then by total in-flight
  pairs.sort((a, b) => {
    const aDisc = a.right ? Math.abs(a.left.in_flight.length - a.right.in_flight.length) : 0;
    const bDisc = b.right ? Math.abs(b.left.in_flight.length - b.right.in_flight.length) : 0;
    if (aDisc !== bDisc) return bDisc - aDisc;
    const aInf = a.left.in_flight.length + (a.right?.in_flight.length || 0);
    const bInf = b.left.in_flight.length + (b.right?.in_flight.length || 0);
    return bInf - aInf;
  });

  // Render helper for one side of a pair
  function renderSide(c) {
    if (!c) return '<div class="conn-side conn-side-empty"><span class="muted">no matching endpoint</span></div>';
    const t = c.transport || {};
    const inflight = c.in_flight.length;
    const lastSent = t.last_sent_ago_secs != null ? fmtAge(t.last_sent_ago_secs) + ' ago' : '—';
    const lastRecv = t.last_recv_ago_secs != null ? fmtAge(t.last_recv_ago_secs) + ' ago' : '—';
    const lastRecvWarn = t.last_recv_ago_secs != null && t.last_recv_ago_secs > 5;

    let h = `<div class="conn-side">`;
    h += `<div class="conn-side-head">${procTag(c.process)} <span class="mono muted" style="margin-left:4px">${c.name}</span></div>`;
    h += '<div class="conn-side-stats">';
    h += `<div class="conn-stat"><span class="conn-stat-k">In-Flight</span><span class="conn-stat-v ${inflight > 0 ? 'text-amber' : ''}">${inflight}</span></div>`;
    h += `<div class="conn-stat"><span class="conn-stat-k">Completed</span><span class="conn-stat-v">${c.total_completed.toLocaleString()}</span></div>`;
    h += `<div class="conn-stat"><span class="conn-stat-k">Age</span><span class="conn-stat-v">${fmtAge(c.age_secs)}</span></div>`;
    h += `<div class="conn-stat"><span class="conn-stat-k">Max Conc.</span><span class="conn-stat-v">${c.max_concurrent_requests}</span></div>`;
    h += `<div class="conn-stat"><span class="conn-stat-k">Credit</span><span class="conn-stat-v">${c.initial_credit.toLocaleString()}</span></div>`;
    if (t.frames_sent != null) {
      h += `<div class="conn-stat"><span class="conn-stat-k">Frames Tx</span><span class="conn-stat-v">${(t.frames_sent||0).toLocaleString()}</span></div>`;
      h += `<div class="conn-stat"><span class="conn-stat-k">Frames Rx</span><span class="conn-stat-v">${(t.frames_received||0).toLocaleString()}</span></div>`;
      h += `<div class="conn-stat"><span class="conn-stat-k">Bytes Tx</span><span class="conn-stat-v">${fmtBytes(t.bytes_sent||0)}</span></div>`;
      h += `<div class="conn-stat"><span class="conn-stat-k">Bytes Rx</span><span class="conn-stat-v">${fmtBytes(t.bytes_received||0)}</span></div>`;
      h += `<div class="conn-stat"><span class="conn-stat-k">Last Sent</span><span class="conn-stat-v">${lastSent}</span></div>`;
      h += `<div class="conn-stat"><span class="conn-stat-k">Last Recv</span><span class="conn-stat-v ${lastRecvWarn ? 'text-red' : ''}">${lastRecv}</span></div>`;
    }
    h += '</div></div>';
    return h;
  }

  let html = '';

  for (const pair of pairs) {
    const left = pair.left;
    const right = pair.right;
    const leftInf = left.in_flight.length;
    const rightInf = right ? right.in_flight.length : 0;
    const hasDiscrepancy = right && leftInf !== rightInf;
    const totalInf = leftInf + rightInf;

    // Card header: "vx-vfsd ↔ vx-store"
    const leftName = left.process;
    const rightName = right ? right.process : (left.peer_name || '?');
    const pairLabel = `${procTag(leftName)} <span class="muted" style="margin:0 6px">↔</span> ${procTag(rightName)}`;
    const discBadge = hasDiscrepancy
      ? ` <span class="tag" style="background:var(--red-bg);color:var(--red);margin-left:8px">in-flight mismatch: ${leftInf} vs ${rightInf}</span>`
      : '';
    const infBadge = totalInf > 0
      ? ` <span class="tag" style="background:var(--amber-bg);color:var(--amber);margin-left:8px">${totalInf} in-flight</span>`
      : '';

    html += `<div class="card" style="${hasDiscrepancy ? 'border-color:var(--red);' : ''}">`;
    html += `<div class="card-head">${pairLabel}${discBadge}${infBadge}</div>`;
    html += '<div class="conn-pair">';
    html += renderSide(left);
    html += '<div class="conn-pair-divider"></div>';
    html += renderSide(right);
    html += '</div>';
    html += '</div>';
  }

  // Channel credits table (if any connection has them)
  const allCredits = [];
  for (const c of allConnections) {
    if (c.channel_credits) {
      for (const cc of c.channel_credits) {
        allCredits.push({ process: c.process, connection: c.name, peer: c.peer_name, ...cc });
      }
    }
  }
  if (allCredits.length > 0) {
    html += '<div class="card"><div class="card-head">Channel Flow Control Credits</div><table><thead><tr>';
    html += '<th data-sort="p">Process</th>';
    html += '<th data-sort="c">Connection</th>';
    html += '<th data-sort="ch" data-type="n">Channel ID</th>';
    html += '<th data-sort="ic" data-type="n">Incoming Credit</th>';
    html += '<th data-sort="oc" data-type="n">Outgoing Credit</th>';
    html += '</tr></thead><tbody>';
    for (const cc of allCredits) {
      html += '<tr>';
      html += `<td>${procTag(cc.process)}</td>`;
      html += `<td class="mono">${esc(cc.connection)}</td>`;
      html += `<td class="num" data-v="${cc.channel_id}">${cc.channel_id}</td>`;
      html += `<td class="num" data-v="${cc.incoming_credit}">${cc.incoming_credit.toLocaleString()}</td>`;
      html += `<td class="num" data-v="${cc.outgoing_credit}">${cc.outgoing_credit.toLocaleString()}</td>`;
      html += '</tr>';
    }
    html += '</tbody></table></div>';
  }

  panel.innerHTML = html;
  panel.querySelectorAll('table').forEach(makeSortable);
})();

// ═══════════════════════════════════════════════════════════════
// PROCESSES TAB
// ═══════════════════════════════════════════════════════════════

(function buildProcesses() {
  const panel = document.getElementById('panel-processes');
  let html = '<div class="card-grid">';

  for (const d of DUMPS) {
    const color = procColor(d.process_name);
    const conns = d.roam?.connections || [];
    const inf = conns.reduce((s, c) => s + c.in_flight.length, 0);
    const comp = conns.reduce((s, c) => s + c.total_completed, 0);

    html += '<div class="proc-card">';
    html += `<div class="proc-card-head">
      <div class="dot" style="background:${color.hex}"></div>
      <span class="name">${esc(d.process_name)}</span>
      <span class="pid">pid ${d.pid}</span>
    </div>`;
    html += '<div class="proc-card-body">';

    // Key-value grid
    html += '<div class="proc-kv">';
    html += `<div class="proc-kv-item"><span class="k">Connections</span><span class="v">${conns.length}</span></div>`;
    html += `<div class="proc-kv-item"><span class="k">In-Flight</span><span class="v ${inf > 0 ? 'text-amber' : ''}">${inf}</span></div>`;
    html += `<div class="proc-kv-item"><span class="k">Completed</span><span class="v">${comp.toLocaleString()}</span></div>`;
    html += `<div class="proc-kv-item"><span class="k">Timestamp</span><span class="v">${fmtTimestamp(d.timestamp)}</span></div>`;

    // Aggregate transport stats across connections
    const totalFramesTx = conns.reduce((s, c) => s + (c.transport?.frames_sent || 0), 0);
    const totalFramesRx = conns.reduce((s, c) => s + (c.transport?.frames_received || 0), 0);
    const totalBytesTx = conns.reduce((s, c) => s + (c.transport?.bytes_sent || 0), 0);
    const totalBytesRx = conns.reduce((s, c) => s + (c.transport?.bytes_received || 0), 0);
    if (totalFramesTx > 0 || totalFramesRx > 0) {
      html += `<div class="proc-kv-item"><span class="k">Frames Tx/Rx</span><span class="v">${totalFramesTx.toLocaleString()} / ${totalFramesRx.toLocaleString()}</span></div>`;
      html += `<div class="proc-kv-item"><span class="k">Bytes Tx/Rx</span><span class="v">${fmtBytes(totalBytesTx)} / ${fmtBytes(totalBytesRx)}</span></div>`;
    }

    if (d.shm) {
      html += `<div class="proc-kv-item"><span class="k">SHM Segments</span><span class="v">${d.shm.segments.length}</span></div>`;
      if (d.shm.channels && d.shm.channels.length > 0) {
        html += `<div class="proc-kv-item"><span class="k">SHM Channels</span><span class="v">${d.shm.channels.length}</span></div>`;
      }
    }
    if (d.locks && d.locks.locks.length > 0) {
      html += `<div class="proc-kv-item"><span class="k">Contended Locks</span><span class="v text-amber">${d.locks.locks.length}</span></div>`;
    }

    // Custom kv
    const customKeys = Object.keys(d.custom || {});
    for (const k of customKeys) {
      html += `<div class="proc-kv-item"><span class="k">${esc(k)}</span><span class="v">${esc(d.custom[k])}</span></div>`;
    }
    html += '</div>'; // proc-kv

    // Recent completions per connection
    for (const c of conns) {
      if (!c.recent_completions || c.recent_completions.length === 0) continue;
      html += '<div class="proc-section">';
      html += `<details><summary>${esc(c.name)}: ${c.recent_completions.length} recent completions</summary>`;
      html += '<table style="margin-top:6px"><thead><tr><th>Method</th><th>Dir</th><th>Duration</th><th>Ago</th></tr></thead><tbody>';
      for (const rc of c.recent_completions) {
        const m = rc.method_name || ('method_' + rc.method_id);
        html += '<tr>';
        html += `<td class="mono">${esc(m)}</td>`;
        html += `<td>${dirArrow(rc.direction)}</td>`;
        html += `<td class="num">${fmtDuration(rc.duration_secs)}</td>`;
        html += `<td class="num muted">${fmtAge(rc.age_secs)} ago</td>`;
        html += '</tr>';
      }
      html += '</tbody></table></details>';
      html += '</div>';
    }

    // Channels
    for (const c of conns) {
      if (!c.channels || c.channels.length === 0) continue;
      html += '<div class="proc-section">';
      html += `<details><summary>${esc(c.name)}: ${c.channels.length} open channels</summary>`;
      html += '<table style="margin-top:6px"><thead><tr><th>Channel ID</th><th>Dir</th><th>Age</th><th>Request ID</th></tr></thead><tbody>';
      for (const ch of c.channels) {
        html += '<tr>';
        html += `<td class="mono">${ch.channel_id}</td>`;
        html += `<td>${ch.direction === 'Tx' ? '<span class="text-green">tx</span>' : '<span class="text-blue">rx</span>'}</td>`;
        html += `<td class="num">${fmtAge(ch.age_secs)}</td>`;
        html += `<td class="mono">${ch.request_id != null ? ch.request_id : '<span class="muted">—</span>'}</td>`;
        html += '</tr>';
      }
      html += '</tbody></table></details>';
      html += '</div>';
    }

    html += '</div>'; // proc-card-body
    html += '</div>'; // proc-card
  }

  html += '</div>'; // card-grid
  panel.innerHTML = html;
})();

// ═══════════════════════════════════════════════════════════════
// SHM TAB
// ═══════════════════════════════════════════════════════════════

(function buildShm() {
  const panel = document.getElementById('panel-shm');
  const segments = [];
  const channels = [];
  for (const d of DUMPS) {
    if (!d.shm) continue;
    for (const seg of d.shm.segments) {
      segments.push({ process: d.process_name, pid: d.pid, ...seg });
    }
    if (d.shm.channels) {
      for (const ch of d.shm.channels) {
        channels.push({ process: d.process_name, pid: d.pid, ...ch });
      }
    }
  }

  if (segments.length === 0 && channels.length === 0) {
    panel.innerHTML = '<div class="empty-state"><div class="icon">∅</div><p>No SHM data</p><p class="sub">No process reported shared memory segments or channels</p></div>';
    return;
  }

  let html = '';

  // Segments table
  if (segments.length > 0) {
    html += '<div class="card"><div class="card-head">Shared Memory Segments</div><table><thead><tr>';
    html += '<th data-sort="p">Process</th>';
    html += '<th data-sort="path">Path</th>';
    html += '<th data-sort="sz" data-type="n">Current / Total</th>';
    html += '<th data-sort="peers" data-type="n">Peers</th>';
    html += '<th data-sort="gb">Host Goodbye</th>';
    html += '</tr></thead><tbody>';

    for (const seg of segments) {
      html += '<tr>';
      html += `<td>${procTag(seg.process)}</td>`;
      html += `<td class="mono">${esc(seg.segment_path || '?')}</td>`;
      html += `<td class="num" data-v="${seg.current_size}">${fmtBytes(seg.current_size)} / ${fmtBytes(seg.total_size)}</td>`;
      html += `<td class="num" data-v="${seg.peers.length}">${seg.peers.length} / ${seg.max_peers}</td>`;
      html += `<td>${seg.host_goodbye ? '<span class="text-red">yes</span>' : 'no'}</td>`;
      html += '</tr>';
    }
    html += '</tbody></table></div>';

    // Peer detail cards per segment
    for (const seg of segments) {
      if (seg.peers.length === 0) continue;
      html += `<div class="card"><div class="card-head">${procTag(seg.process)} ${esc(seg.segment_path || 'segment')} — Peers</div>`;
      html += '<table><thead><tr>';
      html += '<th data-sort="id" data-type="n">ID</th>';
      html += '<th data-sort="nm">Name</th>';
      html += '<th data-sort="st">State</th>';
      html += '<th data-sort="tx" data-type="n">Sent</th>';
      html += '<th data-sort="rx" data-type="n">Received</th>';
      html += '<th data-sort="cs" data-type="n">Calls Sent</th>';
      html += '<th data-sort="cr" data-type="n">Calls Recv</th>';
      html += '<th data-sort="hb" data-type="n">Heartbeat</th>';
      html += '<th data-sort="buf" data-type="n">Buffer</th>';
      html += '</tr></thead><tbody>';
      for (const p of seg.peers) {
        html += '<tr>';
        html += `<td class="mono" data-v="${p.peer_id}">${p.peer_id}</td>`;
        html += `<td>${esc(p.name || '?')}</td>`;
        html += `<td>${esc(p.state)}</td>`;
        html += `<td class="num" data-v="${p.bytes_sent}">${fmtBytes(p.bytes_sent)}</td>`;
        html += `<td class="num" data-v="${p.bytes_received}">${fmtBytes(p.bytes_received)}</td>`;
        html += `<td class="num" data-v="${p.calls_sent || 0}">${(p.calls_sent || 0).toLocaleString()}</td>`;
        html += `<td class="num" data-v="${p.calls_received || 0}">${(p.calls_received || 0).toLocaleString()}</td>`;
        html += `<td class="num" data-v="${p.time_since_heartbeat_ms ?? -1}">${p.time_since_heartbeat_ms != null ? p.time_since_heartbeat_ms + 'ms' : '<span class="muted">—</span>'}</td>`;
        html += `<td class="num" data-v="${p.bipbuf_capacity}">${fmtBytes(p.bipbuf_capacity)}</td>`;
        html += '</tr>';
      }
      html += '</tbody></table></div>';

      // Var pool info
      if (seg.var_pool && seg.var_pool.length > 0) {
        html += `<div class="card"><div class="card-head">${procTag(seg.process)} ${esc(seg.segment_path || 'segment')} — Var Pool</div>`;
        html += '<table><thead><tr>';
        html += '<th data-sort="ss" data-type="n">Slot Size</th>';
        html += '<th data-sort="spe" data-type="n">Slots/Extent</th>';
        html += '<th data-sort="ec" data-type="n">Extents</th>';
        html += '<th data-sort="ts" data-type="n">Total Slots</th>';
        html += '<th data-sort="fs" data-type="n">Free Slots</th>';
        html += '</tr></thead><tbody>';
        for (const c of seg.var_pool) {
          const pctFree = c.total_slots > 0 ? (c.free_slots_approx / c.total_slots * 100).toFixed(0) : 0;
          html += '<tr>';
          html += `<td class="num" data-v="${c.slot_size}">${fmtBytes(c.slot_size)}</td>`;
          html += `<td class="num" data-v="${c.slots_per_extent}">${c.slots_per_extent}</td>`;
          html += `<td class="num" data-v="${c.extent_count}">${c.extent_count}</td>`;
          html += `<td class="num" data-v="${c.total_slots}">${c.total_slots}</td>`;
          html += `<td class="num" data-v="${c.free_slots_approx}">${c.free_slots_approx} <span class="muted">(${pctFree}%)</span></td>`;
          html += '</tr>';
        }
        html += '</tbody></table></div>';
      }
    }
  }

  // Channels table
  if (channels.length > 0) {
    html += '<div class="card"><div class="card-head">Auditable Channels</div><table><thead><tr>';
    html += '<th data-sort="p">Process</th>';
    html += '<th data-sort="nm">Name</th>';
    html += '<th data-sort="len" data-type="n">Length</th>';
    html += '<th data-sort="cap" data-type="n">Capacity</th>';
    html += '<th data-sort="pct" data-type="n">Usage</th>';
    html += '</tr></thead><tbody>';

    for (const ch of channels) {
      const pct = ch.capacity > 0 ? (ch.len / ch.capacity * 100).toFixed(0) : 0;
      const warn = ch.capacity > 0 && ch.len / ch.capacity > 0.8;
      html += '<tr>';
      html += `<td>${procTag(ch.process)}</td>`;
      html += `<td class="mono">${esc(ch.name)}</td>`;
      html += `<td class="num ${warn ? 'text-amber' : ''}" data-v="${ch.len}">${ch.len.toLocaleString()}</td>`;
      html += `<td class="num" data-v="${ch.capacity}">${ch.capacity.toLocaleString()}</td>`;
      html += `<td class="num ${warn ? 'text-amber' : ''}" data-v="${pct}">${pct}%</td>`;
      html += '</tr>';
    }
    html += '</tbody></table></div>';
  }

  panel.innerHTML = html;
  panel.querySelectorAll('table').forEach(makeSortable);
})();

// ═══════════════════════════════════════════════════════════════
// LOCKS TAB
// ═══════════════════════════════════════════════════════════════

(function buildLocks() {
  const panel = document.getElementById('panel-locks');
  const allLocks = [];
  for (const d of DUMPS) {
    if (!d.locks) continue;
    for (const lock of d.locks.locks) {
      allLocks.push({ process: d.process_name, pid: d.pid, ...lock });
    }
  }

  if (allLocks.length === 0) {
    panel.innerHTML = '<div class="empty-state"><div class="icon">∅</div><p>No instrumented locks</p><p class="sub">No process reported lock diagnostics</p></div>';
    return;
  }

  let html = '<div class="card"><div class="card-head">Instrumented Locks</div><table><thead><tr>';
  html += '<th data-sort="p">Process</th>';
  html += '<th data-sort="nm">Lock Name</th>';
  html += '<th data-sort="acq" data-type="n">Acquires</th>';
  html += '<th data-sort="rel" data-type="n">Releases</th>';
  html += '<th data-sort="h" data-type="n">Holders</th>';
  html += '<th data-sort="w" data-type="n">Waiters</th>';
  html += '</tr></thead><tbody>';

  for (const lock of allLocks) {
    const warnWaiters = lock.waiters.length > 0;
    html += '<tr>';
    html += `<td>${procTag(lock.process)}</td>`;
    html += `<td class="mono">${esc(lock.name)}</td>`;
    html += `<td class="num" data-v="${lock.acquires}">${lock.acquires.toLocaleString()}</td>`;
    html += `<td class="num" data-v="${lock.releases}">${lock.releases.toLocaleString()}</td>`;
    html += `<td class="num" data-v="${lock.holders.length}">${lock.holders.length}</td>`;
    html += `<td class="num ${warnWaiters ? 'text-red' : ''}" data-v="${lock.waiters.length}">${lock.waiters.length}</td>`;
    html += '</tr>';
  }
  html += '</tbody></table></div>';

  // Holder/waiter detail cards
  for (const lock of allLocks) {
    if (lock.holders.length === 0 && lock.waiters.length === 0) continue;
    html += `<div class="card"><div class="card-head">${procTag(lock.process)} ${esc(lock.name)}</div>`;
    html += '<table><thead><tr><th>Role</th><th>Kind</th><th>Duration</th><th>Backtrace</th></tr></thead><tbody>';

    for (const h of lock.holders) {
      html += '<tr>';
      html += '<td class="text-amber">Holder</td>';
      html += `<td class="mono">${esc(h.kind)}</td>`;
      html += `<td class="num">${fmtDuration(h.held_secs)}</td>`;
      html += `<td>${expandBtn(h.backtrace)}</td>`;
      html += '</tr>';
    }
    for (const w of lock.waiters) {
      html += '<tr class="severity-danger">';
      html += '<td class="text-red">Waiter</td>';
      html += `<td class="mono">${esc(w.kind)}</td>`;
      html += `<td class="num">${fmtDuration(w.waiting_secs)}</td>`;
      html += `<td>${expandBtn(w.backtrace)}</td>`;
      html += '</tr>';
    }
    html += '</tbody></table></div>';
  }

  panel.innerHTML = html;
  panel.querySelectorAll('table').forEach(makeSortable);
})();

// ═══════════════════════════════════════════════════════════════
// THREADS TAB
// ═══════════════════════════════════════════════════════════════

(function buildThreads() {
  const panel = document.getElementById('panel-threads');
  const allThreads = [];
  for (const d of DUMPS) {
    if (!d.threads) continue;
    for (const t of d.threads) {
      allThreads.push({ process: d.process_name, pid: d.pid, ...t });
    }
  }

  if (allThreads.length === 0) {
    panel.innerHTML = '<div class="empty-state"><div class="icon">∅</div><p>No thread stacks captured</p><p class="sub">Thread registration may not be active, or SIGPROF handler not installed</p></div>';
    return;
  }

  // ── Classify threads ──────────────────────────────────────
  // idle: parked in known wait locations (epoll, kevent, futex, condvar, park)
  // stuck: same frame across most samples but NOT an idle pattern
  // active: frame changes across samples
  // unresponsive: never responded to SIGPROF

  const IDLE_PATTERNS = [
    'park_internal', 'park_timeout', 'thread_park',
    'epoll_wait', 'kevent', '__psynch_cvwait', '__psynch_mutexwait',
    'futex_wait', 'SYS_futex', 'condvar', 'Condvar',
    'mio::poll', 'tokio::runtime::park', 'tokio::park',
    'tokio::runtime::io::Driver', 'tokio::io::driver',
    'io_uring_enter', 'select$DARWIN', 'pselect',
    'recv_timeout', 'thread::sleep',
  ];

  function classifyThread(t) {
    if (!t.responded || t.responded === 0) return 'unresponsive';
    const samples = t.samples || 1;
    const sameRatio = (t.same_location_count || 0) / Math.max(1, samples - 1);
    const frame = t.dominant_frame || '';

    // Check if the dominant frame matches idle patterns
    const isIdleFrame = IDLE_PATTERNS.some(p => frame.includes(p));

    if (sameRatio >= 0.7) {
      return isIdleFrame ? 'idle' : 'stuck';
    }
    return 'active';
  }

  for (const t of allThreads) {
    t._status = classifyThread(t);
  }

  const statusOrder = { stuck: 0, unresponsive: 1, active: 2, idle: 3 };
  const statusLabel = {
    stuck:        { text: 'stuck',        css: 'text-red',   icon: '⚠' },
    unresponsive: { text: 'unresponsive', css: 'text-red',   icon: '✕' },
    active:       { text: 'active',       css: 'text-green', icon: '●' },
    idle:         { text: 'idle',         css: 'text-muted', icon: '○' },
  };

  const sorted = [...allThreads].sort((a, b) => {
    const so = (statusOrder[a._status] ?? 9) - (statusOrder[b._status] ?? 9);
    if (so !== 0) return so;
    const pc = a.process.localeCompare(b.process);
    if (pc !== 0) return pc;
    return a.name.localeCompare(b.name);
  });

  // ── Summary ───────────────────────────────────────────────
  const counts = { stuck: 0, unresponsive: 0, active: 0, idle: 0 };
  for (const t of allThreads) counts[t._status]++;

  let html = '';

  // Summary badges
  html += '<div class="card"><div class="card-head">Thread Stacks';
  if (counts.stuck > 0) {
    html += ` <span class="tag" style="background:var(--red-bg);color:var(--red);margin-left:8px">${counts.stuck} stuck</span>`;
  }
  if (counts.unresponsive > 0) {
    html += ` <span class="tag" style="background:var(--red-bg);color:var(--red);margin-left:8px">${counts.unresponsive} unresponsive</span>`;
  }
  if (counts.active > 0) {
    html += ` <span class="tag" style="background:var(--green-bg);color:var(--green);margin-left:8px">${counts.active} active</span>`;
  }
  html += ` <span class="muted" style="margin-left:8px;font-weight:400;font-size:12px">${counts.idle} idle</span>`;

  const anySampled = allThreads.some(t => t.samples > 1);
  if (anySampled) {
    const s = allThreads[0]?.samples || 0;
    html += ` <span class="muted" style="margin-left:8px;font-weight:400;font-size:11px">(${s} samples each)</span>`;
  }

  html += '</div><table><thead><tr>';
  html += '<th data-sort="p">Process</th>';
  html += '<th data-sort="nm">Thread</th>';
  html += '<th data-sort="st">Status</th>';
  if (anySampled) {
    html += '<th data-sort="sa" data-type="n">Samples</th>';
    html += '<th data-sort="sl" data-type="n">Same Loc</th>';
  }
  html += '<th data-sort="fr">Dominant Frame</th>';
  html += '<th>Trace</th>';
  html += '</tr></thead><tbody>';

  for (const t of sorted) {
    const st = statusLabel[t._status];
    const rowClass = t._status === 'stuck' ? 'severity-danger' : t._status === 'unresponsive' ? 'severity-danger' : '';
    html += `<tr class="${rowClass}">`;
    html += `<td>${procTag(t.process)} <span class="mono muted">${t.pid}</span></td>`;
    html += `<td class="mono">${esc(t.name)}</td>`;
    html += `<td><span class="${st.css}">${st.icon} ${st.text}</span></td>`;
    if (anySampled) {
      html += `<td class="num" data-v="${t.responded || 0}">${t.responded || 0}/${t.samples || 0}</td>`;
      const slRatio = t.samples > 1 ? (t.same_location_count || 0) / (t.samples - 1) : 0;
      const slClass = slRatio >= 0.7 && t._status === 'stuck' ? 'text-red' : slRatio >= 0.7 ? 'text-muted' : '';
      html += `<td class="num ${slClass}" data-v="${t.same_location_count || 0}">${t.same_location_count || 0}/${Math.max(0, (t.samples || 1) - 1)}</td>`;
    }
    const frame = t.dominant_frame || (t.backtrace ? firstUsefulFrame(t.backtrace) : null);
    html += `<td class="mono" style="font-size:10px;max-width:400px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap" title="${frame ? esc(frame) : ''}">${frame ? esc(frame) : '<span class="muted">—</span>'}</td>`;
    html += `<td>${t.backtrace ? expandBtn(t.backtrace) : '<span class="muted">—</span>'}</td>`;
    html += '</tr>';
  }
  html += '</tbody></table></div>';

  panel.innerHTML = html;
  panel.querySelectorAll('table').forEach(makeSortable);
})();

// ═══════════════════════════════════════════════════════════════
// TASKS
// ═══════════════════════════════════════════════════════════════

(function buildTasks() {
  const panel = document.getElementById('panel-tasks');
  const allTasks = [];
  for (const d of DUMPS) {
    if (!d.tasks) continue;
    for (const t of d.tasks) {
      allTasks.push({ process: d.process_name, pid: d.pid, ...t });
    }
  }

  if (allTasks.length === 0) {
    panel.innerHTML = '<div class="empty-state"><div class="icon">∅</div><p>No tracked tasks</p><p class="sub">Task tracking may not be initialized or no tasks were spawned with spawn_tracked()</p></div>';
    return;
  }

  // Update badge
  const pendingOrPolling = allTasks.filter(t => t.state !== 'Completed').length;
  document.getElementById('badge-tasks').textContent = pendingOrPolling;

  // Sort: Polling > Pending > Completed, then by age descending
  const stateOrder = { Polling: 0, Pending: 1, Completed: 2 };
  const sorted = [...allTasks].sort((a, b) => {
    const so = (stateOrder[a.state] ?? 9) - (stateOrder[b.state] ?? 9);
    if (so !== 0) return so;
    return b.age_secs - a.age_secs; // oldest first
  });

  let html = '';
  html += '<div class="card"><div class="card-head">Tracked Tasks';
  
  const polling = allTasks.filter(t => t.state === 'Polling').length;
  const pending = allTasks.filter(t => t.state === 'Pending').length;
  const completed = allTasks.filter(t => t.state === 'Completed').length;

  if (polling > 0) {
    html += ` <span class="tag" style="background:var(--amber-bg);color:var(--amber);margin-left:8px">${polling} polling</span>`;
  }
  if (pending > 0) {
    html += ` <span class="tag" style="background:var(--blue-bg);color:var(--blue);margin-left:8px">${pending} pending</span>`;
  }
  if (completed > 0) {
    html += ` <span class="muted" style="margin-left:8px;font-weight:400;font-size:12px">${completed} completed</span>`;
  }

  html += '</div><table><thead><tr>';
  html += '<th data-sort="p">Process</th>';
  html += '<th data-sort="id" data-type="n">ID</th>';
  html += '<th data-sort="nm">Name</th>';
  html += '<th data-sort="st">State</th>';
  html += '<th data-sort="age" data-type="n">Age (s)</th>';
  html += '<th data-sort="polls" data-type="n"># Polls</th>';
  html += '<th data-sort="lastpoll" data-type="n">Last Poll (s ago)</th>';
  html += '<th>Last Duration</th>';
  html += '<th>Backtrace</th>';
  html += '</tr></thead><tbody>';

  for (const t of sorted) {
    const stuckPolling = t.state === 'Polling' && t.poll_events.length > 0 && t.poll_events[t.poll_events.length - 1].duration_secs === null;
    const rowClass = stuckPolling ? 'severity-warning' : '';
    
    let stateLabel = '';
    if (t.state === 'Polling') {
      stateLabel = '<span class="text-amber">● polling</span>';
    } else if (t.state === 'Pending') {
      stateLabel = '<span class="text-blue">○ pending</span>';
    } else {
      stateLabel = '<span class="text-muted">✓ completed</span>';
    }

    html += `<tr class="${rowClass}">`;
    html += `<td>${procTag(t.process)} <span class="mono muted">${t.pid}</span></td>`;
    html += `<td class="num" data-v="${t.id}">${t.id}</td>`;
    html += `<td class="mono" style="max-width:300px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap" title="${esc(t.name)}">${esc(t.name)}</td>`;
    html += `<td>${stateLabel}</td>`;
    html += `<td class="num" data-v="${t.age_secs.toFixed(3)}">${t.age_secs.toFixed(3)}</td>`;
    html += `<td class="num" data-v="${t.poll_events.length}">${t.poll_events.length}</td>`;
    
    // Last poll info
    if (t.poll_events.length > 0) {
      const lastPoll = t.poll_events[t.poll_events.length - 1];
      const lastPollAge = t.age_secs - lastPoll.started_at_secs;
      const lastPollAgeClass = lastPollAge > 5 ? 'text-red' : lastPollAge > 1 ? 'text-amber' : '';
      html += `<td class="num ${lastPollAgeClass}" data-v="${lastPollAge.toFixed(3)}">${lastPollAge.toFixed(3)}</td>`;
      
      const duration = lastPoll.duration_secs !== null ? `${(lastPoll.duration_secs * 1000).toFixed(1)}ms` : '<span class="text-amber">polling...</span>';
      html += `<td class="mono" style="font-size:11px">${duration}</td>`;
      
      html += `<td>${lastPoll.backtrace ? expandBtn(lastPoll.backtrace) : (t.spawn_backtrace ? expandBtn(t.spawn_backtrace) : '<span class="muted">—</span>')}</td>`;
    } else {
      html += '<td class="muted">—</td>';
      html += '<td class="muted">—</td>';
      html += `<td>${t.spawn_backtrace ? expandBtn(t.spawn_backtrace) : '<span class="muted">—</span>'}</td>`;
    }
    
    html += '</tr>';
  }
  html += '</tbody></table></div>';

  panel.innerHTML = html;
  panel.querySelectorAll('table').forEach(makeSortable);
})();

// ═══════════════════════════════════════════════════════════════
// SYNC TAB
// ═══════════════════════════════════════════════════════════════

(function buildSync() {
  const panel = document.getElementById('panel-sync');

  // Collect all sync data across processes
  const allMpsc = [];
  const allOneshot = [];
  const allWatch = [];
  const allOnceCell = [];

  for (const d of DUMPS) {
    if (!d.sync) continue;
    for (const ch of (d.sync.mpsc_channels || [])) {
      allMpsc.push({ process: d.process_name, pid: d.pid, ...ch });
    }
    for (const ch of (d.sync.oneshot_channels || [])) {
      allOneshot.push({ process: d.process_name, pid: d.pid, ...ch });
    }
    for (const ch of (d.sync.watch_channels || [])) {
      allWatch.push({ process: d.process_name, pid: d.pid, ...ch });
    }
    for (const cell of (d.sync.once_cells || [])) {
      allOnceCell.push({ process: d.process_name, pid: d.pid, ...cell });
    }
  }

  const totalItems = allMpsc.length + allOneshot.length + allWatch.length + allOnceCell.length;
  if (totalItems === 0) return; // tab stays hidden

  // Show the tab and update badge
  document.getElementById('tab-sync').style.display = '';
  document.getElementById('badge-sync').textContent = totalItems;

  function syncStateBadge(state) {
    const s = String(state);
    if (s === 'Pending')          return '<span class="state-badge state-pending">Pending</span>';
    if (s === 'Sent')             return '<span class="state-badge state-sent">Sent</span>';
    if (s === 'Initialized')      return '<span class="state-badge state-initialized">Initialized</span>';
    if (s === 'Initializing')     return '<span class="state-badge state-initializing">Initializing</span>';
    if (s === 'Empty')            return '<span class="state-badge state-empty">Empty</span>';
    if (s === 'SenderDropped')    return '<span class="state-badge state-dropped">SenderDropped</span>';
    if (s === 'ReceiverDropped')  return '<span class="state-badge state-dropped">ReceiverDropped</span>';
    return `<span class="state-badge state-empty">${esc(s)}</span>`;
  }

  let html = '';

  // ── MPSC Channels ──────────────────────────────────────────
  if (allMpsc.length > 0) {
    // Sort: channels with send_waiters first (backpressure), then by queue depth
    const sorted = [...allMpsc].sort((a, b) => {
      if ((b.send_waiters || 0) !== (a.send_waiters || 0)) return (b.send_waiters || 0) - (a.send_waiters || 0);
      return (b.sent - b.received) - (a.sent - a.received);
    });

    html += '<div class="card"><div class="card-head">MPSC Channels';
    const backpressureCount = allMpsc.filter(c => (c.send_waiters || 0) > 0).length;
    if (backpressureCount > 0) {
      html += ` <span class="tag" style="background:var(--red-bg);color:var(--red);margin-left:8px">${backpressureCount} backpressure</span>`;
    }
    html += '</div><table><thead><tr>';
    html += '<th data-sort="p">Process</th>';
    html += '<th data-sort="nm">Name</th>';
    html += '<th data-sort="ty">Type</th>';
    html += '<th data-sort="cap" data-type="n">Capacity</th>';
    html += '<th data-sort="tx" data-type="n">Sent</th>';
    html += '<th data-sort="rx" data-type="n">Received</th>';
    html += '<th data-sort="q" data-type="n">Queue</th>';
    html += '<th data-sort="sw" data-type="n">Send Waiters</th>';
    html += '<th data-sort="sc" data-type="n">Senders</th>';
    html += '<th data-sort="cl">Closed</th>';
    html += '<th data-sort="age" data-type="n">Age</th>';
    html += '</tr></thead><tbody>';

    for (const ch of sorted) {
      const queueDepth = ch.sent - ch.received;
      const hasBackpressure = (ch.send_waiters || 0) > 0;
      const rowClass = hasBackpressure ? 'severity-danger' : queueDepth > 0 && ch.bounded && ch.capacity > 0 && queueDepth / ch.capacity > 0.8 ? 'severity-warn' : '';
      const typeLabel = ch.bounded
        ? '<span class="tag" style="background:var(--blue-bg);color:var(--blue)">bounded</span>'
        : '<span class="tag" style="background:var(--surface);color:var(--fg-muted)">unbounded</span>';

      html += `<tr class="${rowClass}">`;
      html += `<td>${procTag(ch.process)}</td>`;
      html += `<td class="mono">${esc(ch.name)}</td>`;
      html += `<td>${typeLabel}</td>`;
      html += `<td class="num" data-v="${ch.capacity ?? 0}">${ch.bounded ? (ch.capacity ?? 0).toLocaleString() : '<span class="muted">-</span>'}</td>`;
      html += `<td class="num" data-v="${ch.sent}">${ch.sent.toLocaleString()}</td>`;
      html += `<td class="num" data-v="${ch.received}">${ch.received.toLocaleString()}</td>`;
      html += `<td class="num ${queueDepth > 0 ? 'text-amber' : ''}" data-v="${queueDepth}">${queueDepth.toLocaleString()}</td>`;
      if (hasBackpressure) {
        html += `<td data-v="${ch.send_waiters}"><span class="backpressure-warn">${ch.send_waiters} waiting</span></td>`;
      } else {
        html += `<td class="num" data-v="0">0</td>`;
      }
      html += `<td class="num" data-v="${ch.sender_count}">${ch.sender_count}</td>`;

      // Closed status
      const closedParts = [];
      if (ch.sender_closed) closedParts.push('<span class="text-red">tx</span>');
      if (ch.receiver_closed) closedParts.push('<span class="text-red">rx</span>');
      html += `<td>${closedParts.length > 0 ? closedParts.join(', ') : '<span class="muted">no</span>'}</td>`;

      html += `<td class="num" data-v="${ch.age_secs}">${fmtAge(ch.age_secs)}</td>`;
      html += '</tr>';
    }
    html += '</tbody></table></div>';
  }

  // ── Oneshot Channels ───────────────────────────────────────
  if (allOneshot.length > 0) {
    html += '<div class="card"><div class="card-head">Oneshot Channels';
    const pendingCount = allOneshot.filter(c => c.state === 'Pending').length;
    const droppedCount = allOneshot.filter(c => c.state === 'SenderDropped' || c.state === 'ReceiverDropped').length;
    if (pendingCount > 0) {
      html += ` <span class="tag" style="background:var(--amber-bg);color:var(--amber);margin-left:8px">${pendingCount} pending</span>`;
    }
    if (droppedCount > 0) {
      html += ` <span class="tag" style="background:var(--red-bg);color:var(--red);margin-left:8px">${droppedCount} dropped</span>`;
    }
    html += '</div><table><thead><tr>';
    html += '<th data-sort="p">Process</th>';
    html += '<th data-sort="nm">Name</th>';
    html += '<th data-sort="st">State</th>';
    html += '<th data-sort="age" data-type="n">Age</th>';
    html += '</tr></thead><tbody>';

    const sorted = [...allOneshot].sort((a, b) => {
      // Dropped first, then pending, then sent
      const stateOrder = { SenderDropped: 0, ReceiverDropped: 0, Pending: 1, Sent: 2 };
      const so = (stateOrder[a.state] ?? 9) - (stateOrder[b.state] ?? 9);
      if (so !== 0) return so;
      return b.age_secs - a.age_secs;
    });

    for (const ch of sorted) {
      const rowClass = (ch.state === 'SenderDropped' || ch.state === 'ReceiverDropped') ? 'severity-danger' : '';
      html += `<tr class="${rowClass}">`;
      html += `<td>${procTag(ch.process)}</td>`;
      html += `<td class="mono">${esc(ch.name)}</td>`;
      html += `<td>${syncStateBadge(ch.state)}</td>`;
      html += `<td class="num" data-v="${ch.age_secs}">${fmtAge(ch.age_secs)}</td>`;
      html += '</tr>';
    }
    html += '</tbody></table></div>';
  }

  // ── Watch Channels ─────────────────────────────────────────
  if (allWatch.length > 0) {
    html += '<div class="card"><div class="card-head">Watch Channels</div><table><thead><tr>';
    html += '<th data-sort="p">Process</th>';
    html += '<th data-sort="nm">Name</th>';
    html += '<th data-sort="ch" data-type="n">Changes</th>';
    html += '<th data-sort="rc" data-type="n">Receivers</th>';
    html += '<th data-sort="age" data-type="n">Age</th>';
    html += '</tr></thead><tbody>';

    const sorted = [...allWatch].sort((a, b) => b.age_secs - a.age_secs);

    for (const ch of sorted) {
      html += '<tr>';
      html += `<td>${procTag(ch.process)}</td>`;
      html += `<td class="mono">${esc(ch.name)}</td>`;
      html += `<td class="num" data-v="${ch.changes}">${ch.changes.toLocaleString()}</td>`;
      html += `<td class="num" data-v="${ch.receiver_count}">${ch.receiver_count}</td>`;
      html += `<td class="num" data-v="${ch.age_secs}">${fmtAge(ch.age_secs)}</td>`;
      html += '</tr>';
    }
    html += '</tbody></table></div>';
  }

  // ── OnceCell ───────────────────────────────────────────────
  if (allOnceCell.length > 0) {
    html += '<div class="card"><div class="card-head">OnceCell Instances';
    const initializingCount = allOnceCell.filter(c => c.state === 'Initializing').length;
    if (initializingCount > 0) {
      html += ` <span class="tag" style="background:var(--blue-bg);color:var(--blue);margin-left:8px">${initializingCount} initializing</span>`;
    }
    html += '</div><table><thead><tr>';
    html += '<th data-sort="p">Process</th>';
    html += '<th data-sort="nm">Name</th>';
    html += '<th data-sort="st">State</th>';
    html += '<th data-sort="age" data-type="n">Age</th>';
    html += '<th data-sort="dur" data-type="n">Init Duration</th>';
    html += '</tr></thead><tbody>';

    const sorted = [...allOnceCell].sort((a, b) => {
      const stateOrder = { Initializing: 0, Empty: 1, Initialized: 2 };
      const so = (stateOrder[a.state] ?? 9) - (stateOrder[b.state] ?? 9);
      if (so !== 0) return so;
      return b.age_secs - a.age_secs;
    });

    for (const cell of sorted) {
      const rowClass = cell.state === 'Initializing' ? 'severity-warn' : '';
      html += `<tr class="${rowClass}">`;
      html += `<td>${procTag(cell.process)}</td>`;
      html += `<td class="mono">${esc(cell.name)}</td>`;
      html += `<td>${syncStateBadge(cell.state)}</td>`;
      html += `<td class="num" data-v="${cell.age_secs}">${fmtAge(cell.age_secs)}</td>`;
      html += `<td class="num" data-v="${cell.init_duration_secs ?? -1}">${cell.init_duration_secs != null ? fmtDuration(cell.init_duration_secs) : '<span class="muted">-</span>'}</td>`;
      html += '</tr>';
    }
    html += '</tbody></table></div>';
  }

  panel.innerHTML = html;
  panel.querySelectorAll('table').forEach(makeSortable);
})();

</script>
</body>
</html>
